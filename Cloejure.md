# Clojure
## Что такое Clojure?

Clojure — Lisp'ообразный язык общего назначения, разработанный для Java Virtual Machine (JVM). Автором языка является Rich Hickey.
Clojure является функциональным языком программирования с поддержкой функций в качестве объектов первого класса (first class objects) и неизменяемыми (за исключением специальных случаев) данными, включая поддержку "ленивых" коллекций данных. От Lisp'а Clojure "унаследовал" макросы, мультиметоды и интерактивный стиль разработки, а JVM дает переносимость и доступ к большому набору библиотек, созданных для этой платформы.
В Clojure используется динамическая типизация, однако при необходимости вы можете задать определенный тип данных, чтобы обеспечить максимальную производительность критически важных фрагментов кода. Clojure не просто работает на JVM, он разрабатывался с учетом операционной совместимости с Java. Кроме того, создатели Clojure ориентировались на поддержку многопоточности, так что Clojure предоставляет разработчикам уникальные возможности для параллельного программирования.

За счет того, что Clojure был спроектирован для работы на базе JVM, обеспечивается доступ к большому набору библиотек, существующих для данной платформы. Взаимодействие с Java реализуется в обе стороны — как вызов кода, написанного на Java, так и реализация классов, которые доступны как для вызова из Java, так и из других языков, существующих для JVM, например, Scala.

## Установка

Установка Clojure достаточно проста — скачайте последнюю версию с [сайта языка](https://clojure.org/) и распакуйте в нужный каталог. После этого вы можете запустить ее с помощью команды:
```
	java -cp clojure.jar clojure.main
```
Эта команда приведет к запуску JVM и вы получите доступ к REPL ("read-eval-print loop" — цикл ввода выражений и выдачи результатов).


## Главные отличия от Common Lisp:

 - идентификаторы в Clojure регистрозависимы (case-sensitive);
 - большая часть данных — неизменяемая;
 - пользователь не может изменять синтаксис языка путем ввода собственных макросов в процедуре чтения кода (read macros);
 - введен специальный синтаксис для литералов, векторов, отображений (maps), регулярных выражений, анонимных функций и т.д.;
 - существует возможность связывания метаданных с переменными и функциями;
 - можно реализовать функции с одним именем и разным набором аргументов;
 - многие привычные вещи, такие как let, по синтаксису отличаются от их аналогов в Common Lisp и Scheme (при этом используется меньше скобок), например, let связывает данные последовательно, аналогично let* в Scheme;
 - вместо функций car и cdr используются функции first и rest;
 - nil не равен пустому списку или другому набору данных (коллекции) — он всего лишь означает отсутствующее значение (аналог null в Java);
 - используется общее пространство имен, как в Scheme;
 - сравнение на равенство производится одной функцией в отличие от Common Lisp и Scheme;
поддержка "ленивых" коллекций.

## Из чего состоит язык Clojure

Синтаксис языка Clojure следует стандартному для Lisp'образных языков подходу "код как данные", когда данные и код имеют общий синтаксис. Как и в других диалектах Lisp'а, код записывается в виде списков, используя префиксную нотацию и представляя собой синтаксическое дерево. Однако по сравнению с другими языками, в Clojure введены дополнительные сущности: кроме стандартных для Lisp'а символов, базовых литералов (строки, числа и т.п.) и списков, в язык введен дополнительный синтаксис для векторов, отображений (maps) и множеств (sets), являющихся объектами первого класса (first class objects).

Кроме этого, процедура чтения кода (reader) распознает специфические для Clojure конструкции: @ — для доступа к изменяемым данным и различные конструкции, начинающиеся с символа # — анонимные функции, метаданные (включая информацию о типах данных), регулярные выражения и т.д. Процедура чтения также рассматривает пробелы и запятые между элементами языка как один символ, разделяющий эти элементы.

## Основные типы данных
Данные в Clojure можно разделить на две большие группы: базовые типы данных — числа, строки и т.д., и последовательности (коллекции), к которым относятся списки, векторы, отображения и множества. Пользователь может определять свои структуры данных с помощью defstruct, но они являются частным случаем отображений и введены для обеспечения более эффективной работы со сложными данными.
Все типы данных имеют общий набор характеристик: данные неизменяемы и реализуют операцию "равенство" (equality).

К базовым типам данных Clojure относятся следующие:

 - логические значения - в языке определено два объекта для представления логических значений: true — для истинного значения и false — для ложного. (Все остальные значения, кроме false и nil, рассматриваются как истинные);
 
 - числа - в языке могут использоваться числа разных типов. По умолчанию для представления целых чисел используются классы, унаследованные от java.lang.Number — Integer, BigInteger, BigDecimal, но в Clojure реализуется специальный подход, который позволяет представлять число наиболее эффективным способом, автоматически преобразуя числа в случае необходимости — например, при переполнении числа. Если вы хотите для целого числа явно указать тип BigDecimal, то вы можете добавить букву M после значения.
Для чисел с плавающей точкой используется стандартный класс Double.

Кроме этих видов чисел, в Clojure определен специальный тип Ratio, представляющий числа в виде рациональных дробей, что позволяет избегать ошибок округления — например, при делении.

 - строки - строки в Clojure являются экземплярами класса java.lang.String и к ним можно применять различные функции определенные в этом классе. Форма записи строк Clojure совпадает со стандартной записью строк в Java;
 
 - знаки (characters) - являются экземплярами класса java.lang.Character и записываются либо в форме \N, где N — соответствующая буква, либо как названия для неотображаемых букв — например, как \tab и \space для символа табуляции и пробела и т.д.;
 
 - символы (symbols) - используются для ссылки на что-то — параметры функций, имена классов, глобальные переменные и т.д. Для представления символа как отдельного объекта, а не как значения, для которого он используется в качестве имени, используется стандартная запись 'symbol (или специальная форма quote);
 
 - keywords (ключевые символы) - это специальные символы, имеющие значение самих себя3, аналогично символам (symbols) в Lisp и Ruby. Одним из важных их свойств является очень быстрая операция проверки на равенство, поскольку происходит проверка на равенство указателей. Это свойство делает их очень удобными для использования в качестве ключей в отображениях (maps) и тому подобных вещах. Для именованных аргументов существует специальная форма записи.

Стоит также отметить, что символы и keywords имеют некоторую общность — в рамках интерфейса IFn для них создается функция invoke() с одним аргументом, что позволяет использовать символы и keywords в качестве функции. Например, конструкция (:mykey my-hash-map) или ('mysym my-hash-map) аналогичны вызову (get my-hash-map :mykey) или (get my-hash-map 'mysym), который приведет к извлечению значения с нужным ключом из соответствующего отображения.

В языке Clojure имеется специальное значение nil, которое может использоваться как значение любого типа данных, и совпадающее с null в Java. nil может использоваться в условных конструкциях наравне со значением false. Однако стоит отметить, что, в отличие от Lisp, nil и пустой список — () не являются взаимозаменяемыми и использование пустого списка в условной конструкции будет рассматриваться как значение true;


Коллекции, последовательности и массивы
Кроме общих характеристик базовых типов перечисленных выше, все коллекции в Clojure имеют следующие характеристики:

 - вся работа с коллекциями проводится через общий интерфейс;
 - существует возможность связывания метаданных с коллекцией;
 - для коллекций реализуются интерфейсы java.lang.Iterable и java.util.Collection, что позволяет работать с ними из Java;
 - все коллекции рассматриваются как "последовательности" данных, вне зависимости от конкретного представления данных внутри них.

Неизменяемость коллекций означает, что результатом работы всех операций по модификации коллекций является другая, новая коллекция, в то время как исходная коллекция остается неизменной. В Clojure существует эффективный механизм, помогающий реализовывать неизменяемые коллекции. С его помощью операции, изменяющие коллекцию, могут эффективно создавать "измененную" версию данных, которая использует большую часть исходных данных, не создавая полной копии.

В текущей версии Clojure реализованы следующие основные виды коллекций:

 - списки (lists) записываются точно также как и в других реализациях Lisp. В Clojure списки напрямую реализуют интерфейс ISeq, что позволяет функциям работы с последовательностями эффективно работать с ними. (При использовании функции conj новые элементы списков добавляются в начало);
 -  векторы (vectors) -представляют собой последовательности, элементы которых индексируются целым числом (с последовательными значениями индекса в диапазоне 0..N, где N — размер вектора). Для определения вектора необходимо заключить его элементы в квадратные скобки, например, [1 2 3]. Для преобразования других коллекций в вектор можно использовать функции vector или vec. Поскольку вектор индексируется целым числом, то операция доступа к произвольному элементу реализуется достаточно эффективно, что удобно при работе с некоторыми видами данных. (При использовании функции conj новые элементы векторов добавляются в конец.)
 
Кроме того, для вектора в Clojure создается функция одного аргумента (целого числа — индекса значения) с именем, совпадающим с именем символа, связанным с вектором. Это позволяет использовать имя вектора в качестве функции для доступа к нужному значению. Например, вызов (v 3) в данном коде:

```Clojure
> (def v [1 2 3 4 5 "string"])
> (v 3)
4
```

 -  отображения (maps) - это специальный вид последовательности, который отображает одни значения данных (ключ) в другие (значения). В Clojure существуют два вида отображений: hash-map и sorted-map, которые создаются с помощью соответствующих функций. hash-map обеспечивает более быстрый доступ к данным, а sorted-map хранит данные в отсортированном по ключу виде. Отображения записываются в виде набора значений (с четным количеством элементов), заключенных в фигурные скобки. Значения, стоящие на нечетных позициях рассматриваются как ключи, а на четных — как значения, связанные с данным ключом. В качестве ключа могут использоваться любые поддерживаемые Clojure типы данных, но очень часто в качестве ключей используют keywords, поскольку для них реализована очень быстрая проверка на равенство.
Также как и для векторов, для отображений создается функция одного аргумента (ключа), которая позволяет использовать имя символа, связанного с отображением, для доступа к элементам. Например,
```Clojure
> (def m {:1 1 :abc 33 :2 "2" })
>/m
> (m :abc)
33
```
 -  множества (sets) - представляет собой набор уникальных значений. Также как и для отображений, существует два вида множеств — hash-set и sorted-set. Определение множества имеет следующий вид #{elements...}, а для создания множества из других коллекций может использоваться функция set, например, для получения множества уникальных значений вектора, можно использовать следующий код:
```Clojure
>(set [1 2 3 2 1 2 3])
{1 2 3}
```

В Clojure также определены дополнительные виды отображений, позволяющие в специальных случаях добиться большей производительности:

 -  отображения-структуры (struct maps) могут использоваться для эмуляции записей (records), имеющихся в других языках программирования. В этом случае отображения имеют набор одинаковых ключей и Clojure реализует эффективное хранение информации о ключах, а также предоставляет быстрый доступ к элементам по ключу. В случае необходимости, имеется возможность генерации специализированной функции доступа с помощью функции accessor.
Определение отображения-структуры производится с помощью макроса defstruct или функции create-struct. Новые экземпляры отображений создаются с помощью функции struct-map или struct, которые получают список элементов для заполнения данного отображения. При этом стоит отметить, что отображение-структура может иметь большее количество ключей, чем было определено в defstruct — в этом отношении, отображения-структуры ведут себя точно также, как и обычные отображения.

 -  отображения-массивы (array maps)
это специальный вид отображений, в котором сохраняется порядок ключей. Такие отображения реализованы в виде обычного массива, содержащего ключи и значения. Поиск в отображении является линейной функцией от количества элементов, и поэтому, такие отображения должны использоваться только для хранения небольшого количества элементов. Новые отображения-массивы могут создаваться с помощью функции array-map.

Работа с коллекциями выполняется единообразно — для всех коллекций поддерживаются операции count для получения размера коллекции, conj для добавления элементов в коллекцию (реализуется по-разному, в зависимости от конкретного типа) и seq для представления коллекции в виде последовательности — это позволяет применять к ним функции работы с последовательностями: cons, first, map и т.д. Функцию seq также можно использовать для преобразования в последовательности и коллекций Java.

## Пример программ 

### Hello, World!:
```Clojure
>(printf "Hello, World!")
Hello, World!
```
### Факториал
```Clojure
>(defn factorial [x]
  (if (< x 2)
    1
    (* x (factorial (dec x)))))

>(factorial 3))
6
```

### Цикл от 1 до 10
```Clojure
(doseq [i (range 10)]
  (println (str (str i "! = "))
```


### Fibb:
```Clojure
>(defn fibonacci [x]
  (if (< x 2)
    x
    (+ (fibonacci (- x 1)) (fibonacci (- x 2)) )))
>(fibonacci 3)


```
https://clojure.org/
https://habr.com/ru/post/173071/
http://alexott.net/ru/clojure/clojure-intro/
https://www.ibm.com/developerworks/ru/library/os-eclipse-clojure/index.html
